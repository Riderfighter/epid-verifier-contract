use std::mem;
#[cfg(not(feature = "library"))]
use cosmwasm_std::entry_point;
use cosmwasm_std::{Addr, BankMsg, Binary, CanonicalAddr, Coin, ConversionOverflowError, CosmosMsg, Deps, DepsMut, ensure, ensure_eq, ensure_ne, Env, has_coins, MessageInfo, Order, Response, StdError, StdResult, to_binary, to_json_binary, Uint128, Uint256};
use cw_storage_plus::Bounder;
use sha2::{Digest, Sha256};
use crate::ContractError::Std;
// use cw2::set_contract_version;

use crate::error::ContractError;
use crate::intelstructs::{ClaimStruct, IASReport, INTEL_ROOT_EXPONENT, INTEL_ROOT_MODULUS, recover_signature_digest};
use crate::msg::{ExecuteMsg, FetchDonorsResponse, FetchRewardedResponse, FetchSeenGroupIds, InstantiateMsg, QueryMsg};
use crate::platforminfoblob::{convert_claim_struct_to_payload, convert_platform_info_hex, get_payload_from_quote_body};
use crate::state::{DonationInfo, DONATIONS, REWARD_POT, REWARDED, RewardInfo, RewardPot, SEEN_GROUP_IDS};

/*
// version info for migration info
const CONTRACT_NAME: &str = "crates.io:epid-verifier-lotto";
const CONTRACT_VERSION: &str = env!("CARGO_PKG_VERSION");
*/

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -> Result<Response, ContractError> {
    ensure! {
        msg.total_reward_shares > Uint256::zero(),
        StdError::generic_err("Total reward shares must be greater than 0")
    };

    let state = RewardPot {
        total_reward_units: msg.total_reward_shares,
        GEIDs: Default::default(),
        pot_of_rewards: Default::default(),
    };

    REWARD_POT.save(deps.storage, &state).unwrap();

   Ok(Response::new())
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> StdResult<Response> {
    match msg {
        ExecuteMsg::ClaimGEID { report, to_claim } => claim_geid(deps, env, info, report, to_claim),
        ExecuteMsg::DonateToPot { } => donate_to_pot(deps, env, info)
    }
}

fn claim_geid(deps: DepsMut, env: Env, info: MessageInfo, report: IASReport, claim_struct: ClaimStruct) -> StdResult<Response> {
    // Load the reward pot from the state
    let mut pot_data = REWARD_POT.load(deps.storage).unwrap();
    // Take the message sender and convert them from human address to canonical
    let canonical_claimant = deps.api.addr_canonicalize(info.sender.as_str()).unwrap();

    // Grab the hex encoded platform info blob
    let pib = report.report.platform_info_blob.clone();
    // Convert the platform info blob from hex to struct, hence the "fr" aka for real
    let pib_fr = convert_platform_info_hex(pib.as_str()).unwrap();
    // Because we're storing the group id we want to make this 4 bytes representing the u32
    let group_id: [u8; 4] = pib_fr.gid.to_be_bytes();

    // Load the ISV enclave quote body, encoded as base64, into a `Binary` struct
    let quote_body = Binary::from_base64(report.report.isv_enclave_quote_body.as_str()).unwrap();

    // Extract the payload from the quote body
    let payload = get_payload_from_quote_body(quote_body.as_slice());

    // Convert the claim struct to the stringified claim struct
    let hashed_claim_struct = convert_claim_struct_to_payload(claim_struct);

    // Ensure that the claim struct generated by an enclave, stored in the payload field, is equal to the one that was passed in..
    ensure_eq!(payload, hashed_claim_struct, StdError::generic_err("Payload and ClaimStruct do not have matching content."));

    // Convert the ias report as a json string, removing all the backslashes to escape stuff
    let ias_report_asjson = serde_json::to_string(&report.report).unwrap().replace("\\", "");
    // Convert the ias report without the back slashes to bytes
    let ias_report_asbytes = ias_report_asjson.as_bytes();

    // Convert the base64 ias report signature into a Binary object from base64
    let ias_report_sig = Binary::from_base64(report.report_sig.as_str()).unwrap();
    // Convert the base64 object into a byte slice
    let ias_report_sig_bytes = ias_report_sig.as_slice();

    // Recover the RSA signature's digest
    let recovered_digest = recover_signature_digest(ias_report_sig_bytes, INTEL_ROOT_EXPONENT, INTEL_ROOT_MODULUS);
    // Convert the recovered digest into a byte slice
    let recovered_digest = recovered_digest.as_slice();

    // We are going to calculate our own digest of the ias report
    let mut hasher = Sha256::default();

    // Update the hasher contents with that of the ias report json
    hasher.update(ias_report_asbytes);

    // finalize the sha256 hasher so that it produces a byte slice of the digest, should be 32 bytes
    let sha256d_claim = &hasher.finalize()[..];

    // ensure that the recovered digest from the signature matches the digest of the report
    ensure_eq!(sha256d_claim, recovered_digest, StdError::generic_err("The recovered digest doesn't match the submitted Report's digest"));
    // ensure that we haven't seen the group id we want to claim before
    ensure!(SEEN_GROUP_IDS.has(deps.storage, group_id.to_vec()) != true, StdError::generic_err(format!("Group ID : {:?} has already been seen before!", group_id)));
    // add the group id to `SEEN_GROUP_IDS` so that the previous check fails on an already claimed Group ID
    SEEN_GROUP_IDS.save(deps.storage, group_id.to_vec(), &canonical_claimant.to_vec()).unwrap();

    // calculate the rewards that the claimant will get
    let claimed = pot_data.claim_rewards(deps.storage, canonical_claimant, env.block.time.seconds());

    // lets fit the reward into a Uint128, if the reward is too large that is going to be a rip
    let claimed_to_u128 = match Uint128::try_from(claimed) {
        Ok(amt) => {
            amt
        }
        Err(_) => {
            return Err(StdError::generic_err("We're trying to convert too large of a number to a Uint128, lets hope this never happens ^-^"))
        }
    };

    // remove from the pot of rewards the amount that was claimed
    pot_data.pot_of_rewards -= claimed;

    // build a Coin struct to use to send coins
    let coin_to_send = Coin::new(claimed_to_u128.u128(), "ujuno");

    // save the changes done to the reward pot
    REWARD_POT.save(deps.storage, &pot_data).unwrap();

    // send a response from the contract that transfers the amount of funds the claimant was meant to get
    Ok(Response::default().add_message(CosmosMsg::Bank(BankMsg::Send { to_address: info.sender.to_string(), amount: vec![coin_to_send] })))
}

fn donate_to_pot(deps: DepsMut, env: Env, info: MessageInfo) -> StdResult<Response> {
    // Check if the transfer has sent a minimum of 0.000001 juno
    if has_coins(&info.funds, &Coin { denom: "ujuno".to_string(), amount: Uint128::from(1u128) }) {
        // Load the reward pot
        let mut pot_data = REWARD_POT.load(deps.storage).unwrap();

        // Figure out the amount of juno that was donated
        let amount_donated = Uint256::from(info.funds.as_slice().get(0).unwrap().amount);

        // The donor is the message sender
        let donor = info.sender;

        // Canonicalize the donor address
        let canonicalized_donor = deps.api.addr_canonicalize(donor.as_str()).unwrap();

        // Add the donation to the pot
        pot_data.add_donation(deps.storage, canonicalized_donor, amount_donated, env.block.time.seconds()).unwrap();

        // Save the reward pot with its changes
        REWARD_POT.save(deps.storage, &pot_data).unwrap();

        // Emit an event from the contract that indicates a donation was done
        Ok(Response::default().add_attribute("donation", amount_donated.to_string()))
    } else {
        // Inform the user that their act of wanting to donate is appreciated :)
        Err(StdError::generic_err("Your generous donation has been noted :) Thank you!"))
    }
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::FetchDonors { page, page_size } => fetch_donors(deps, page, page_size),
        QueryMsg::FetchClaimants { page, page_size } => fetch_claimants(deps, page, page_size),
        QueryMsg::FetchSeenGuids { page, page_size } => fetch_seen_group_ids(deps, page, page_size),
    }
}

fn fetch_seen_group_ids(deps: Deps, page: u64, page_size: u64) -> StdResult<Binary> {
    let seen_group_ids: Vec<_> = SEEN_GROUP_IDS.range(deps.storage, None, None, Order::Ascending).skip((page * page_size) as usize).take(page_size as usize).map(|x| x.unwrap()).collect();

    let mut actual_geids: Vec<u32> = Vec::new();

    for group_pair in seen_group_ids {
        let group_id = group_pair.0;

        ensure!(group_id.len() == 4, StdError::generic_err("The group id that was previously submitted didn't work"));


        let mut container: [u8; 4] = [0, 0, 0 ,0];

        for group_id_i in 0..group_id.len() {
            let group_byte = group_id[group_id_i];

            container[group_id_i] = group_byte;
        }

        let group_id_int = u32::from_be_bytes(container);

        actual_geids.push(group_id_int);
    }

    let response = FetchSeenGroupIds {
        rewarded: actual_geids,
    };

    let ser_response = to_json_binary(&response).unwrap();

    Ok(ser_response)
}

fn fetch_claimants(deps: Deps, page: u64, page_size: u64) -> StdResult<Binary> {
    let rewarded: Vec<(Vec<u8>, RewardInfo)> = REWARDED.range(deps.storage, None, None, Order::Ascending).skip((page * page_size) as usize).take(page_size as usize).map(|x| x.unwrap()).collect();

    let rewarded: Vec<(Addr, RewardInfo)> = rewarded.iter().map(|x| (deps.api.addr_humanize(&CanonicalAddr::from(x.0.clone())).unwrap(), x.1.clone())).collect();

    let rewarded_info: FetchRewardedResponse = FetchRewardedResponse { rewarded };
    
    let ser_rewarded = to_json_binary(&rewarded_info).unwrap();

    Ok(ser_rewarded)
}

fn fetch_donors(deps: Deps, page: u64, page_size: u64) -> StdResult<Binary> {
    let donors: Vec<_> = DONATIONS.range(deps.storage, None, None, Order::Ascending).skip((page * page_size) as usize).map(|x| x.unwrap()).take(page_size as usize).collect();

    let donors: Vec<(Addr, DonationInfo)> = donors.iter().map(|x| (deps.api.addr_humanize(&CanonicalAddr::from(x.0.clone())).unwrap(), x.1.clone())).collect();
    
    let donation_info: FetchDonorsResponse = FetchDonorsResponse { donors };

    let ser_donors = to_json_binary(&donation_info).unwrap();

    Ok(ser_donors)
}

#[cfg(test)]
mod tests {
    use cosmwasm_std::{Addr, Api, CanonicalAddr, Order, StdResult, to_json_binary};
    use cosmwasm_std::testing::mock_dependencies;
    use crate::msg::FetchDonorsResponse;
    use crate::state::{DonationInfo, DONATIONS};

    #[test]
    fn test_max_reward_shares() {
        let mock_deps = mock_dependencies();
        let mut storage = mock_deps.storage;
        let to_save = &[(Vec::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106, 49, 117, 103, 118, 118, 102, 56, 101, 48, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 117, 108, 121, 110, 100, 117, 118, 57, 120, 57, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110, 114, 50, 101, 107, 99, 103, 117, 112, 57, 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 99, 56, 121, 112, 55, 54, 54, 99, 48]), DonationInfo { donation_size: Default::default(), last_donation: 0 }), (Vec::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106, 49, 117, 103, 118, 118, 102, 56, 101, 48, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 117, 108, 121, 110, 100, 117, 118, 57, 120, 57, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110, 114, 50, 101, 107, 99, 103, 117, 112, 57, 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 99, 56, 121, 112, 55, 54, 54, 99, 49]), DonationInfo { donation_size: Default::default(), last_donation: 0 }), (Vec::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106, 49, 117, 103, 118, 118, 102, 56, 101, 48, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 117, 108, 121, 110, 100, 117, 118, 57, 120, 57, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110, 114, 50, 101, 107, 99, 103, 117, 112, 57, 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 99, 56, 121, 112, 55, 54, 54, 99, 50]), DonationInfo { donation_size: Default::default(), last_donation: 0 })];

        for save in to_save {
            DONATIONS.save(&mut storage, save.0.clone(), &save.1).unwrap();
            println!("[!] Saved a new record in the database.")
        }

        let page = 0u64;
        let page_size = 2u64;

        // let donors = DONATIONS.range(&storage, None, None, Order::Ascending).take(page_size as usize).collect::<Vec<StdResult<(Vec<u8>, DonationInfo)>>>();

        // println!("{:?}", donors);

        let donors: Vec<(Vec<u8>, DonationInfo)> = DONATIONS.range(&storage, None, None, Order::Ascending).skip((page * page_size) as usize).take(page_size as usize).map(|x| x.unwrap()).collect();

        println!("{:?}", donors);

        let donors: Vec<_> = donors.iter().map(|x| (mock_deps.api.addr_humanize(&CanonicalAddr::from(x.0.clone())).unwrap(), x.1.clone())).collect();

        println!("{:?}", donors);

        let donation_info: FetchDonorsResponse = FetchDonorsResponse { donors };

        let ser_donors = to_json_binary(&donation_info).unwrap();


        println!("{:?}", ser_donors)
    }

    #[test]
    fn test_canonicalize_addr() {
        let mock_deps = mock_dependencies();
        let address = Addr::unchecked("juno1lrcuy28gneyvdkpvuc7fvg689u6expc0990s4r");

        let canonical_addr = mock_deps.api.addr_canonicalize(address.as_str()).unwrap();

        println!("{:?}", canonical_addr)
    }
}
